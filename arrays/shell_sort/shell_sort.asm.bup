%include "defines.inc"
%include "asm_io.inc"

;
; function shell_sort
; C-callable function that sorts a given array using the bubble sort algorithm
;
; C prototype:
; void shell_sort( const int * a, int n);
; Parameters:
;   a - pointer to array to sort (at ebp+8 on stack)
;   n - number of integers to sort (at ebp+12 on stack)

;# Sort an array a[0...n-1].
;gaps = [701, 301, 132, 57, 23, 10, 4, 1]

;# Start with the largest gap and work down to a gap of 1
;foreach (gap in gaps)
; begin
;    # Do a gapped insertion sort for this gap size.
;    # The first gap elements a[0..gap-1] are already in gapped order
;    # keep adding one more element until the entire array is gap sorted
;    for (i = gap; i < n; i += 1)
;    begin
;        # add a[i] to the elements that have been gap sorted
;        # save a[i] in temp and make a hole at position i
;        temp = a[i]
;        # shift earlier gap-sorted elements up until the correct location for a[i] is found
;        for (j = i; j >= gap and a[j - gap] > temp; j -= gap)
;        begin
;            a[j] = a[j - gap]
;        end
;        # put temp (the original a[i]) in its correct location
;        a[j] = temp
;    end
; end

; procedure shellSort()
;   A : array of items 
;	
;   /* calculate interval*/
;   while interval < A.length /3 do:
;      interval = interval * 3 + 1	    
;   end while
;   
;   while interval > 0 do:
;
;      	for outer = interval; outer < A.length; outer ++ do:
;      		/* select value to be inserted */
;      		valueToInsert = A[outer]
;      		inner = outer;
;
;         	/*shift element towards right*/
;         	while inner > interval -1 && A[inner - interval] >= valueToInsert do:
;            		A[inner] = A[inner - interval]
;            		inner = inner - interval
;         	end while
;
;      		/* insert the number at hole position */
;      		A[inner] = valueToInsert
;      	end for
;
;   /* calculate interval*/
;	interval = (interval -1) /3;	  
;
;   end while
;   
;end procedure
; 
%define N   dword [ebp+12]
%define A   dword [ebp+8]
%define I   esi
%define J   edi
%define FRAME_SIZE 16
%define	gap_count dword [ebp-4]
%define	gap 	dword [ebp-8]
%define tmp  dword[ebp-12]

segment .data
msg db "shell_sort(%d):  %d",10,0
;gaps: dw 701, 301, 132, 57, 23, 10, 4, 1
gaps: dd 5, 3, 1
num_gaps: equ ($-gaps)/ESIZE

segment .text
        global  shell_sort
        extern 	printf

shell_sort:
        enter   FRAME_SIZE,0
        pusha 
	mov 	ecx,num_gaps
for01:
	mov	eax,ecx
	sub 	eax,num_gaps
        or 	eax,eax			; make sure that eax is the absolute value
	jc 	positive_value
	neg 	eax
positive_value:
	mov     eax,[gaps+ESIZE*eax]
	mov     gap,eax
	mov 	I,gap
for02:
	cmp 	I,N
	jge     end_for02
	mov 	ebx,A
	mov 	eax,[ebx+ESIZE*I]
	mov 	tmp,eax
	mov 	J,I
for03:
	cmp 	J,gap
	jl	end_for03
	mov 	eax,A
	mov 	edx,J
	sub 	edx,gap
	lea 	eax,[eax+ESIZE*edx]
	mov 	ebx,[eax]
	cmp 	ebx,tmp
	jl	end_for03
	mov 	ebx,A
	lea 	ebx,[ebx+ESIZE*J]
	mov 	eax,[eax]
	mov 	[ebx],eax
	sub	J,gap
	jmp 	for03

end_for03:
	mov 	ebx,A
	mov 	edx,J
	lea 	ebx,[ebx+ESIZE*edx]
	mov 	edx,tmp
	mov 	[ebx],edx
        inc 	I
	jmp 	for02
end_for02:
	loop 	for01
end_for01:

done:
        popa
        leave
        ret
